---
layout: post
title: "[STUDY] 관심사항"
date:   2016-11-21 09:00:00 +0900
categories: network study
---

## 관심사항 리스트
- 하이퍼바이져란?


## ## Transaction Isolation Level
트랜잭션 간의 격리를 의미
레벨이 높을 수록 동시성은 떨어지고 일관성은 높아진다. 즉 변경에 대해 더 방어적이게 된다. 

### 일반적인 분류
- Read Uncommitted
- Read Committed
- Repeatable Read
- Serializable

#### Read Uncommitted
Shared-Lock 이 걸리지 않는 레벨
A라는 데이터를 B로 변경하는 동안에는 다른 사용자는 해당 데이터에 접근할 수 있다.

#### Read Committed
Shared-Lock 이 걸리는 레벨
A라는 데이터를 B로 변경하는 동안에는 다른 사용자는 해당 데이터에 접근할 수 없다.

#### Repeatable Read
트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리므로 
다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능합니다. 
가령, Select col1 from A where col1 between 1 and 10을 수행하였고 이 범위에 해당하는 데이터가 2건이 있는 경우(col1=1과 5) 
다른 사용자가 col1이 1이나 5인 Row에 대한 UPDATE이 불가능합니다. 
하지만, col1이 1과 5를 제외한 나머지 이 범위에 해당하는 Row를 INSERT하는 것이 가능합니다.


#### Serializable
트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리므로 
다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능합니다. 
예를 들어, Repeatable Read의 경우 1에서 10 사이에 해당되는 데이터에 대한 UPADTE이 가능하였습니다. 
하지만 이 Level에서는 UPDATE 작업도 허용하지 않습니다. 

## Lock 의 종류

### Shared-Lock
읽기 연산을 수행하기 전에 획득하는 Lock , 여러 트랜잭션이 획득 가능
isolation level에 따라서 읽은 후에 바로 Lock 을 푸는 경우가 있고 풀지 않는 경우가 있다.
case 1) READ COMMITTED(4)인 경우 트랜잭션 T1이 커밋되기 전이라도 읽기 연산을 완료하면 획득한 공유 잠금을 즉시 해제
        다른 트랜잭션 중 하나가 해당 객체에 대한 갱신 또는 삭제 연산을 수행할 수 있다.
case 2) EPEATABLE READ(5)인 경우, 트랜잭션 T1이 커밋될 때까지 공유 잠금을 유지
        다른 트랜잭션 중 하나가 해당 객체에 대한 갱신 또는 삭제 연산을 수행할 수 없다.

### Execlusive-Lock
객체에 대한 `갱신연산을 수행하기 전`에 획득함. 하나의 트랜잭션만 획득

~~~
트랜잭션 T1이 특정 객체 X에 대해 갱신 연산을 수행하기 전에 배타 잠금을 먼저 획득하고, 
갱신 연산을 완료하더라도 트랜잭션 T1이 커밋될 때까지 배타 잠금을 해제하지 않는다. 
따라서, 트랜잭션 T2, T3은 트랜잭션 T1이 배타 잠금을 해제하기 전까지는 X에 대한 읽기 연산도 수행할 수 없다.
~~~

### Update-Lock
갱신연산을 수행하기 전, 조건절에서 읽기 연산을 수행할 때 획득하는 잠금이다.
즉, update ... where ... , delete ... where 문에서 사용된다.

~~~
예를 들어 WHERE 절과 결합된 UPDATE 문을 수행하는 경우, 
WHERE 절에서 인덱스 검색을 하거나 풀 스캔 검색을 수행할 때 행 단위로 갱신 잠금을 획득하고, 
조건을 만족하는 결과 행들에 대해서만 배타 잠금을 획득하여 갱신 연산을 수행한다. 
이처럼 갱신 잠금은 실제 갱신 연산을 수행할 때 배타 잠금으로 변환되며, 
이는 다른 트랜잭션이 동일한 객체에 대해 읽기 연산을 수행하지 못하도록 하므로 준 배타 잠금이라고 할 수 있다.
~~~

### 키잠금
키가 존재하는 행에 대해서는 CRUD 작업시에 키에 대한 잠금을 획득한다.
INSERT = 해당 키에 X_LOCK, 해당키와 다음키에 NS_LOCK을 획득한다.
UPDATE/DELETE = 지정한 범위에 해당하는 모든 키와 범위내 가장 마지막 키의 다음키에 NX_LOCK을 획득한다.

#### Next-Key Shared Lock, NS_LOCK
고유 키가 존재하는 행에 대해 Insert 를 수행할 때 
해당 작업이 영향을 주는 범위를 보호하기 위해 다음키에 대핸 잠금을 획득한다.

#### Next-Key Execlusive Lock, NX_LOCK
고유 키가 존재하는 행에 대해서 UPDATE, DELETE 작업 수행시
해당 작업이 영향을 주는 범위를 보호하기 위해 이전키와 다음키에 잠금을 획득한다. 

### Update-Lock


### Example
- index scan을 통해 삭제할 row와 그 다음 row를 찾아 U_LOCK을 획득.
- 삭제할 row에 X_LOCK을 획득.
- 테이블에 존재하는 다른 모든 index에 대해 현재 삭제하려는 row의 다음 key에 해당하는  row에 대해 NX_LOCK을 획득.
